#!/usr/bin/ruby

require 'pp'
require 'haml'
require 'yaml'
require 'time'
require 'sinatra'
require 'sequel'
require 'bcrypt'
require 'net/http'
require 'rack/protection'
require './email_builder.rb'

Sequel.default_timezone = :local
DB = Sequel.connect("sqlite://#{Dir.pwd}/bof-o-matic.sqlite3")
CFG = YAML.load(File.read("bof-o-matic.yaml"))

use Rack::Protection
use Rack::Protection::EscapedParams

configure do
  set :host_authorization, { permitted_hosts: [] }

  set :conference_name, CFG['conference_name']
  set :base_url, CFG['base_url']
  set :use_short_urls, CFG['use_short_urls']
  set :conference_start_time, Time.parse(CFG['conference_starts'])
  set :conference_end_time, Time.parse(CFG['conference_ends'])
  set :slot_length, CFG['slot_length']
  set :generate_pdfs, CFG['generate_pdfs']
  set :generate_pngs, CFG['generate_pngs']
  set :png_width, CFG['png_width']
  set :png_height, CFG['png_height']
  set :png_font, CFG['png_font']
  set :interest_threshold, CFG['interest_threshold']
  set :kiosk_timeout, CFG['kiosk_timeout']
  set :selfschedule_delay, CFG['selfschedule_delay']
end


# bring in all the Sequel models for talking to the DB
require './bom_models.rb'

# bring in the classes that extend the models, these have to come after bom_models
require './bom_pdf.rb' if CFG['generate_pdfs']
require './bom_png.rb' if CFG['generate_pngs']

enable :sessions
set :session_secret, CFG['session_secret']
set :port, 4590
set :method_override, true

helpers do
  def nav_link(uri: '', text: '', extra_class: '')
    haml_tag :li, class: 'nav-item'
    if(request.path_info == uri) then
      haml_tag :a, text, href: uri, class: "nav-link active #{extra_class}", 'aria-current': :page
    else
      haml_tag :a, text, href: uri, class: "nav-link #{extra_class}"
    end
  end

end


def require_logged_in
  redirect '/login' unless session[:user]
end

def is_logged_in?
  session[:user]
end

def is_self_scheduling?
  session[:scheduling_token]
end

def kiosk_mode?
  session[:kiosk_mode]
end

def kiosk_mode_url
  session[:kiosk_mode_url]
end

not_found do
  'Path not found.' 
end

get '/'  do
  redirect '/proposals'
end

get '/proposals' do
  @proposals = Proposal.association_left_join(:interest)
    .select(Sequel[:proposals][:id], :title, :description, :submitted_by, :name, :room_id)
    .association_left_join(:schedule)
    .select_more{Sequel.as(count(:name), :count)}
    .group(:title)

  haml :proposals
end

get '/proposals/new' do
  haml :proposal_add
end

post '/proposals/new' do
  data = {
    :submitted_by => params[:name],
    :submitter_email => params[:email],
    :submitter_phone => params[:phone],
    :title => params[:title],
    :description => params[:description],
    :scheduler_notes => params[:notes]
  }
  new_id = DB[:proposals].insert(data)

  redirect "/proposals/#{new_id}"
end

get '/proposals/:id' do
  @proposal = Proposal[params[:id]]
  return "No such proposal found." unless @proposal
  haml :proposal
end

get %r{/(?<id>\d+)} do
  raise Sinatra::NotFound unless settings.use_short_urls
  redirect "/proposals/#{params['captures'].first}"
end

# for un-scheduling a BoF
delete '/schedules/:id' do
  require_logged_in

  Proposal[params[:proposal_id]].to_cancel_label_png settings: settings, filename: "png-spool/#{Time.now.to_i.to_s}-proposal#{params[:proposal_id]}-cancel.png" if settings.generate_pngs

  Schedule[params[:id]].destroy

  queue_emails_when_unscheduled params[:proposal_id], session[:user]

  redirect "/"
end

# for destroying a BoF
delete '/proposals/:id' do
  require_logged_in

  Proposal[params[:id]].interest_dataset.each do |interest|
    interest.destroy
  end
  Proposal[params[:id]].destroy

  redirect "/"
end


get '/proposals/:id/interest' do
  @proposal = Proposal[params[:id]]
  haml :interest_add
end

post '/proposals/:id/interest' do
  data = {
    :proposal_id => params[:id],
    :name => params[:name],
    :email => params[:email],
    :phone => params[:phone],
  }
  data[:submitted_at] = Time.now
  DB[:interests].insert(data)

  if(Interest.where(proposal_id: params[:id]).count == settings.interest_threshold) then
    queue_interest_email_to_proposer(params[:id], settings.selfschedule_delay, settings.base_url)
  end

  redirect "/proposals/#{params[:id]}"
end

get '/grid' do
  @proposals = Proposal.association_left_join(:interest)
    .association_join(schedule: :room)
    .select(Sequel[:proposals][:id], :title, :description, :name, :start_time, :room_name, Sequel[:room][:id].as(:room_id))
    .select_more{Sequel.as(count(:name), :count)}
    .group(:title)
  
  if is_logged_in? then
    @unscheduled_proposals = Proposal.association_left_join(:interest)
      .association_left_join(:schedule)
      .select(Sequel[:proposals][:id], :title, :description, :submitted_by, :name, :scheduler_notes)
      .where(start_time: nil)
      .select_more{Sequel.as(count(:name), :count)}
      .group(:title)
    @rooms = Room.where(active: true)
  elsif is_self_scheduling? then
    @unscheduled_proposals = Proposal.association_left_join(:interest)
      .association_left_join(:schedule)
      .select(Sequel[:proposals][:id], :title, :description, :submitted_by, :name, :scheduler_notes)
      .where(start_time: nil, scheduling_token: session[:scheduling_token])
      .select_more{Sequel.as(count(:name), :count)}
      .group(:title)
    @rooms = Room.where(active: true)
  end

  haml :grid
end

post '/grid' do
  redirect '/login' unless is_logged_in? or is_self_scheduling?

  scheduled_by = session[:user]

  if(is_self_scheduling?) then
    # validate that the token and session they're scheduling match
    # just in case there's any funny business
    proposal = DB[:proposals].where(scheduling_token: session[:scheduling_token]).first
    return "Unable to schedule due to mismatch between token and ID. Please contact an admin." unless proposal[:id] == params[:proposal_id].to_i
    scheduled_by = proposal[:submitted_by]
  end

  data = {
    :proposal_id => params[:proposal_id],
    :room_id => params[:room_id],
    :start_time => Time.parse(params[:timeslot]).strftime("%Y-%m-%d %H:%M:%S"),
    :scheduled_by => scheduled_by
  }
  DB[:schedules].insert(data)

  Proposal[params[:proposal_id]].to_pdf filename: "pdf-spool/#{Time.now.to_i.to_s}-proposal#{params[:id]}.pdf" if settings.generate_pdfs
  Proposal[params[:proposal_id]].to_label_png settings: settings, filename: "png-spool/#{Time.now.to_i.to_s}-proposal#{params[:proposal_id]}.png" if settings.generate_pngs

  queue_emails_when_scheduled(params[:proposal_id])
  session.delete :scheduling_token

  redirect '/grid'
end

get '/proposals/:id/print' do
  require_logged_in

  Proposal[params[:id]].to_pdf filename: "pdf-spool/#{Time.now.to_i.to_s}-proposal#{params[:id]}.pdf" if settings.generate_pdfs
  Proposal[params[:id]].to_label_png settings: settings, filename: "png-spool/#{Time.now.to_i.to_s}-proposal#{params[:proposal_id]}.png" if settings.generate_pngs

  redirect "/proposals/#{params[:id]}"
end

get '/rooms' do
  require_logged_in

  @rooms = Room.all

  haml :rooms
end

post '/rooms' do
  require_logged_in

  if(params[:action] == 'toggle_active') then
    room = Room[params[:id]]
    room.active = !room.active
    room.save
  elsif(params[:action] == 'rename') then
    room = Room[params[:id]]
    room.room_name = params[:name]
    room.save
  elsif(params[:action] == 'add') then
    room = Room.new(room_name: params[:name])
    room.save
  end

  redirect '/rooms'
end

get '/schedulers' do
  require_logged_in

  @schedulers = Scheduler.all

  haml :schedulers
end

post '/schedulers' do
  require_logged_in
  
  if(params[:action] == 'delete') then
    Scheduler[params[:id]].destroy
  elsif(params[:action] == 'add') then
    @new_passwd = "correct horse #{File.readlines("token-words.txt").sample(2).map {|t| t.strip}.join(" ")}"
    @new_username = params[:username]
    pwhash = BCrypt::Password.create(@new_passwd)
    scheduler = Scheduler.new(
      username: params[:username],
      email: params[:email],
      phone: params[:phone],
      pwhash: pwhash
    )
    scheduler.save

    return haml :scheduler_add
  elsif(params[:action] == 'reset') then
    @new_passwd = "correct horse #{File.readlines("token-words.txt").sample(2).map {|t| t.strip}.join(" ")}"
    user = Scheduler[params[:id]]
    user.update pwhash: BCrypt::Password.create(@new_passwd)
    user.save

    return haml :scheduler_resetpass
  end

  redirect '/schedulers'
end

get '/scheduler/:id' do
  @scheduler = Scheduler[params[:id]]

  haml :scheduler
end

post '/scheduler/:id' do
  user = Scheduler[params[:id]]
  user.update email: params[:email], phone: params[:phone]
  user.save

  redirect '/schedulers'
end

get '/apikeys' do
  require_logged_in

  @apikeys = ApiKey.all

  haml :apikeys
end

post '/apikeys' do
  require_logged_in

  if(params[:action] == 'delete') then
    ApiKey[params[:id]].destroy
  elsif(params[:action] == 'add') then
    apikey = ApiKey.new(
      key: [*('a'..'z'),*('A'..'Z'),*('0'..'9')].shuffle[0,31].join,
      access_level: params[:access_level],
      description: params[:desc],
      issued_by: session[:user]
    )
    apikey.save
  end

  redirect '/apikeys'
end

get '/apikey/:id' do
  @apikey = ApiKey[params[:id]]

  haml :apikey
end

get '/mails' do
  require_logged_in

  @mails = Mail.all

  haml :mails
end

get '/mails/:id' do
  require_logged_in

  @mail = Mail[params[:id]]
  haml :mail
end

get '/texts' do
  require_logged_in

  @texts = Text.all

  haml :texts
end

get '/texts/:id' do
  require_logged_in

  @text = Text[params[:id]]
  haml :text
end

get '/kiosk' do
  require_logged_in

  @kiosk_mode = session[:kiosk_mode]
  @kiosk_url = session[:kiosk_mode_url]

  haml :kiosk
end

post '/kiosk' do
  require_logged_in

  session[:kiosk_mode] = params['kiosk'] == 'on'
  session[:kiosk_mode_url] = params['url']

  redirect '/kiosk'
end

get '/kiosk_timeout' do
  # log any logged-in user out and redirect to where we've been asked to go
  session.delete :user
  session.delete :scheduling_token

  redirect session['kiosk_mode_url']
end

get '/selfschedule' do
  haml :selfschedule
end

get '/selfschedule/:token' do
  haml :selfschedule
end

post '/selfschedule' do
  redirect '/selfschedule' unless params[:token]

  # TODO: should be case-insensitive and allow for extra whitespace probably
  proposal = DB[:proposals].where(scheduling_token: params[:token]).first
  if(!proposal) then
    @message = "Invalid token, please check your email and try again."
    return haml :selfschedule
  end
  schedules = DB[:schedules].where(proposal_id: proposal[:id])
  if(schedules.count > 0) then
    @message = "This session has already been scheduled by #{schedules.first[:scheduled_by]}, the token is now invalid."
    return haml :selfschedule
  end
  session[:scheduling_token] = params[:token]

  redirect '/grid'
end

get '/login' do
  haml :login
end

post '/login' do
  user = DB[:schedulers].where(username: params[:username]).first
  if user and BCrypt::Password.new(user[:pwhash]) == params[:password] then
    session[:user] = params[:username]
    redirect '/'
  else
    redirect '/login'
  end
end

get '/logout' do
  session.delete :user
  session.delete :scheduling_token
  redirect '/'
end

get '/password' do
  require_logged_in

  haml :password
end

post '/password' do
  require_logged_in

  user = Scheduler.where(username: session[:user]).first
  if(params[:new] != params[:newagain]) then
    @message = "New passwords don't match."
    haml :password
  elsif(params[:new].length < 8)
    @message = "New password must be at least 8 characters."
    haml :password
  elsif(BCrypt::Password.new(user[:pwhash]) != params[:existing]) then
    @message = "Existing password is incorrect."
    haml :password
  else
    user.update pwhash: BCrypt::Password.create(params[:new])
    @message = "Password successfully changed."
    haml :password
  end
end

