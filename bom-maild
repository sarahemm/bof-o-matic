#!/usr/bin/ruby

require 'sequel'
require 'yaml'
require 'net/smtp'
require 'logger'
require 'optparse'

# TODO: this works fine but could use some overall reorganizing

def do_mail_run(cfg, db, logger)
  if(cfg['email_hold']) then
    # if we want to hold emails in the queue for testing or because of a system
    # issue, just keep waiting until that flag is removed
    logger.warn "Email queue is on hold in configuration file, waiting..."
    while(cfg['email_hold']) do
      sleep 60
      cfg = YAML.load(File.read("bof-o-matic.yaml"))
    end
    logger.warn "Email queue hold has been released, proceeding"
  end

  Mail.where(status: ['READY', 'RETRY']).each do |message|
    if(cfg['email_to_domain_filter']) then
      unless(cfg['email_to_domain_filter'].include? message[:to_address].split('@')[1]) then
        logger.info "Skipping sending message #{message[:id]} to #{message[:to_address]} as it does not match the defined domain filter (#{cfg['email_to_domain_filter']})"
        next
      end
    end

    extra_headers = ""
    if(message[:body].include? 'Content-Disposition:')
      # it's a MIME multipart email, add the right header for that
      extra_headers = "\nContent-Type: multipart/alternative; boundary=\"boundary-string\""
    end
    email_body = <<~EOF
      From: #{cfg['email_from']}
      To: #{message[:to_address]}
      Subject: #{message[:subject]}#{extra_headers}
      
      #{message[:body]}
    EOF
    begin
      smtp = Net::SMTP.new(cfg['smtp_server'], cfg['smtp_port'])
      smtp.enable_tls if cfg.include? 'smtp_tls' and cfg['smtp_tls']
      from_email = cfg['email_from']
      # if the from email is something like "Example Conference <con@example.com>"
      # the envelope should just have what's in the <>, so extract that
      from_email = from_email.split(/[<>]/)[1] if from_email.include? '<'
      if(cfg.include? 'smtp_username') then
        smtp.start('bof-o-magic', cfg['smtp_username'], cfg['smtp_password'], cfg['smtp_authmethod'].to_sym)
      else
        smtp.start('bof-o-matic')
      end
      smtp.send_message(email_body, from_email, message[:to_address]);
    rescue Net::SMTPFatalError => e
      logger.warn "Fatal error sending message #{message[:id]}: #{e.replace("\n", " ")}, marking as ERROR"
      message.status = 'ERROR'
      message.save
      smtp.finish
    rescue StandardError => e
      logger.warn "Temporary error sending message #{message[:id]}: #{e}, marking as RETRY"
      message.status = 'RETRY'
      message.save
    else
      logger.info "Successfully sent message #{message[:id]} to #{message[:to_address]}"
      if(cfg['keep_sent_mail']) then
        logger.debug "Marking message #{message[:id]} as sent"
        message.status = 'SENT'
        message.save
      else
        logger.debug "Deleting message #{message[:id]} from the queue"
        message.destroy
      end
      smtp.finish
    end
  end
end

logger = Logger.new(STDOUT, progname: 'bom-maild')
logger.level = Logger::WARN

foreground = false
opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

  opts.on("-f", "--foreground", "Don't daemonize, stay in foreground and send logs to stdout") do
    foreground = true
  end

  opts.on("-l", "--log-level=LEVEL", "Log level (debug, info, warn, or error)") do |level|
    logger.level = level
  end
end
opt_parser.parse!

db = Sequel.sqlite("#{Dir.pwd}/bof-o-matic.sqlite3", timeout: 30000)
cfg = YAML.load(File.read("bof-o-matic.yaml"))

require './bom_models.rb'

@signal_rx = false

if(!foreground) then
  logger.reopen("bom-maild.log") # TODO: this should be configurable
  Process.daemon
end

Signal.trap("SIGUSR1") do
  @signal_rx = true
end

while true do
  logger.debug "Starting mail run"
  do_mail_run(cfg, db, logger)
  logger.debug "Finished mail run, going to sleep"
  
  time_left = 60
  while(time_left > 0) do 
    sleep 5
    time_left -= 5
    if(@signal_rx) then
      @signal_rx = false
      logger.debug "SIGUSR1 received, scheduling immediate mail run"
      time_left = 0
    end
  end
end

